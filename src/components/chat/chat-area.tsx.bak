"use client";

import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { useParams } from "next/navigation";
import { FaUser, FaPaperPlane } from "react-icons/fa";
import { useM          } catch (e) {
            console.warn("[Chat] Could not load messages via GET /messages/history:", e);
            
            // If it failed due to a 405 Method Not Allowed error, try again with a different method
            if (e instanceof Error && e.message.includes('405')) {
              try {
                console.log(`[Chat] 405 error detected, trying alternate method for message history`);
                
                // Retry with explicit POST method
                const historyResponse = await getMessageHistory({
                  type: "private",
                  target_id: friendId,
                  limit: 50 // Request more messages to make sure we don't miss any
                });
                
                const hasValidData = historyResponse?.data && Array.isArray(historyResponse.data) && historyResponse.data.length > 0;
                const hasValidMessages = historyResponse?.messages && Array.isArray(historyResponse?.messages) && historyResponse?.messages?.length > 0;
                
                if (hasValidData || hasValidMessages) {
                  const messagesToStore = hasValidData ? historyResponse.data : 
                                       (hasValidMessages && historyResponse.messages) ? historyResponse.messages : [];
                                       
                  setLocalMessages(messagesToStore as Message[]);
                  messagesLoaded = true;
                }
              } catch (retryError) {
                console.error("[Chat] Retry attempt for message history also failed:", retryError);
              }
            }
          }

          // Step 4: If both APIs failed, we'll show an empty chat
          if (!messagesLoaded) {
            console.log("[Chat] Could not load any messages, displaying empty chat");
            // Don't set messages array to empty if it would clear existing messages
            if (localMessages.length === 0) {
              setLocalMessages([]);
              
              // Show less alarming toast notification
              toast.error("Couldn't load previous messages. New messages will still work.", {
                duration: 4000,
                id: "message-critical-error",
              }); as BaseMessage } from "@/hooks/messages/useMessages";
import { useFriendship } from "@/hooks/auth/useFriends";
import { usePresence } from "@/hooks/presence/usePresence";
import { toast } from "react-hot-toast";

// Extended Message interface with UI status properties
interface Message extends BaseMessage {
  pending?: boolean;
  error?: boolean;
  retrying?: boolean;
  retryCount?: number;
  errorMessage?: string;
}

// Define props interface for the component
interface ChatAreaProps {
  recipientId?: string;
  recipientName?: string;
  isGroup?: boolean;
}

// Export both as default and named export for flexibility
export function ChatArea({
  recipientId,
  recipientName,
  isGroup = false,
}: ChatAreaProps) {
  // Use either provided recipientId or extract from URL params
  const params = useParams();
  const friendId =
    recipientId || (params?.friendId as string) || (params?.id as string);
  const { data: session } = useSession();
  const [message, setMessage] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const {
    messages: apiMessages,
    loading: loadingMessages,
    error,
    sendMessage,
    getMessages,
    getMessageHistory,
    getUnreadCount,
  } = useMessages();
  
  // Local messages state for optimistic UI updates and rendering
  const [localMessages, setLocalMessages] = useState<Message[]>([]);

  // Use localMessages as our source of truth but initialize from apiMessages
  useEffect(() => {
    if (apiMessages && apiMessages.length > 0) {
      setLocalMessages(apiMessages as Message[]);
    }
  }, [apiMessages]);

  const { getFriendById, recipientData, setRecipientData } = useFriendship();
  const presence = usePresence();

  // Add state for tracking pending messages to better handle optimistic UI
  const [pendingMessages, setPendingMessages] = useState<{
    [key: string]: boolean;
  }>({});

  useEffect(() => {
    if (friendId) {
      // Log the initialization to help with debugging
      console.log(`[ChatArea] Initializing chat with recipient ID: ${friendId}`);
      
      // Step 1: Load friend details to display in header (first name and last name)
      getFriendById(friendId as string)
        .then(response => {
          console.log('[ChatArea] Friend details loaded:', response);
          // Store friend details including first_name and last_name if available
          if (response && response.data) {
            setRecipientData({
              ...response.data,
              // Make sure we have friendly display name from first and last name
              display_name: response.data.first_name && response.data.last_name 
                ? `${response.data.first_name} ${response.data.last_name}`
                : response.data.display_name || response.data.name
            });
          }
        })
        .catch(err => {
          console.error('[ChatArea] Error loading friend details:', err);
          toast.error('Could not load contact information');
        });

      // Step 2: Get unread message count for this conversation
      const getUnreadMessagesCount = async () => {
        try {
          const unreadResponse = await getUnreadCount();
          console.log('[Chat] Unread message count:', unreadResponse);
        } catch (err) {
          console.warn('[Chat] Failed to get unread count:', err);
        }
      };

      // Get unread count at the beginning
      getUnreadMessagesCount();

      // Step 3: Enhanced message loading with sequential API calls
      const loadMessagesAndHistory = async () => {
        console.log(`[Chat] Loading messages for conversation with ${friendId}`);
        let messagesLoaded = false;

        try {
          // Step 3.1: First try GET /messages API
          try {
            console.log(`[Chat] Starting with GET /messages for friendId: ${friendId}`);
            
            // Add additional error handling for potentially invalid friendId
            if (!friendId || typeof friendId !== 'string') {
              throw new Error(`Invalid friendId: ${friendId}`);
            }
            
            const messageResponse = await getMessages(friendId);

            console.log("[Chat] GET /messages response received:", JSON.stringify({
              hasData: !!messageResponse?.data,
              dataLength: messageResponse?.data?.length,
              hasMessages: !!messageResponse?.messages,
              messagesLength: messageResponse?.messages?.length
            }));

            // Check if we got valid data with safer property access
            const hasValidData = messageResponse?.data && Array.isArray(messageResponse.data) && messageResponse.data.length > 0;
            const hasValidMessages = messageResponse?.messages && Array.isArray(messageResponse?.messages) && messageResponse?.messages?.length > 0;
            
            if (hasValidData || hasValidMessages) {
              const messageCount = 
                (hasValidData ? messageResponse.data.length : 0) || 
                (hasValidMessages && messageResponse.messages ? messageResponse.messages.length : 0);
                
              console.log(`[Chat] Successfully loaded ${messageCount} messages via GET /messages`);
              messagesLoaded = true;
              
              // Process and store the messages
              const messagesToStore = hasValidData ? messageResponse.data : 
                                   (hasValidMessages && messageResponse.messages) ? messageResponse.messages : [];
              
              setLocalMessages(messagesToStore as Message[]);
            } else {
              console.log("[Chat] No messages returned from GET /messages, will try message history API");
            }
          } catch (e) {
            console.warn("[Chat] Could not load messages via GET /messages:", e);
          }

          // Step 3.2: Whether or not GET /messages succeeds, also try GET /messages/history
          // This ensures we have a complete conversation history
          try {
            console.log(`[Chat] Now trying GET /messages/history for friendId: ${friendId}`);
            
            // Ensure friendId is valid before making request
            if (!friendId || typeof friendId !== 'string') {
              throw new Error(`Invalid friendId for message history: ${friendId}`);
            }
            
            const historyResponse = await getMessageHistory({
              type: "private",
              target_id: friendId,
            });

            console.log("[Chat] GET /messages/history response:", JSON.stringify({
              hasData: !!historyResponse?.data,
              dataLength: historyResponse?.data?.length,
              hasMessages: !!historyResponse?.messages,
              messagesLength: historyResponse?.messages?.length
            }));

            // Check if we got valid data with safer property access
            const hasValidData = historyResponse?.data && Array.isArray(historyResponse.data) && historyResponse.data.length > 0;
            const hasValidMessages = historyResponse?.messages && Array.isArray(historyResponse?.messages) && historyResponse?.messages?.length > 0;
            
            if (hasValidData || hasValidMessages) {
              const messageCount = 
                (hasValidData && historyResponse.data ? historyResponse.data.length : 0) || 
                (hasValidMessages && historyResponse.messages ? historyResponse.messages.length : 0);
                
              console.log(`[Chat] Successfully loaded ${messageCount} messages via GET /messages/history`);
              
              // If we already loaded messages from GET /messages, merge the results
              // Otherwise just use the history results
              if (messagesLoaded) {
                console.log('[Chat] Merging messages from both endpoints');
                
                const historyMessages = hasValidData && historyResponse.data ? historyResponse.data : 
                                      hasValidMessages && historyResponse.messages ? historyResponse.messages : [];
                
                // Merge and deduplicate messages based on ID
                const messageMap = new Map();
                
                // Add existing messages
                localMessages.forEach((msg: Message) => {
                  if (msg && msg.id) messageMap.set(msg.id, msg);
                });
                
                // Add new messages, overwriting duplicates with newer data
                historyMessages.forEach((msg: any) => {
                  if (msg && msg.id) messageMap.set(msg.id, msg);
                });
                
                // Convert map back to array and sort by created_at
                const mergedMessages = Array.from(messageMap.values())
                  .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
                
                setLocalMessages(mergedMessages as Message[]);
                console.log(`[Chat] Messages merged: ${mergedMessages.length} total messages`);
              } else {
                // No messages loaded yet, just use the history results
                messagesLoaded = true;
                
                const messagesToStore = hasValidData && historyResponse.data ? historyResponse.data : 
                                     (hasValidMessages && historyResponse.messages) ? historyResponse.messages : [];
                
                setLocalMessages(messagesToStore as Message[]);
              }
            } else if (!messagesLoaded) {
              console.log("[Chat] No messages returned from either endpoint");
            }
          } catch (e) {
            console.warn("[Chat] Could not load messages via GET /messages/history:", e);
          }

          // Step 4: If both APIs failed, we'll show an empty chat
          if (!messagesLoaded) {
            console.log("[Chat] Could not load any messages, displaying empty chat");
            // Don't set messages array to empty if it would clear existing messages
            if (localMessages.length === 0) {
              setLocalMessages([]);
              
              // Show toast notification about message loading failure
              toast.error("Could not load messages. Please try again later.", {
                duration: 4000,
                id: "message-load-error",
              });
            }
          }
        } catch (err: any) {
          const errorMessage = err?.message || "Unknown error";
          console.error(`[Chat] Critical error loading messages: ${errorMessage}`, err);
          
          // Add diagnostic information for troubleshooting
          console.error(`[Chat] Message loading failed for friendId: ${friendId}`);
          console.error(`[Chat] API endpoint structure may need to be verified`);
          
          // Fallback: At least show an empty chat interface rather than failing
          if (localMessages.length === 0) {
            setLocalMessages([]);
            
            // Show toast notification about message loading failure
            toast.error(`Error loading messages: ${errorMessage.substring(0, 50)}${errorMessage.length > 50 ? '...' : ''}`, {
              duration: 4000,
              id: "message-critical-error",
            });
          }
        }
      };

      loadMessagesAndHistory();

      // Setup polling for new messages (optional) with error backoff
      let consecutiveErrors = 0;
      const maxConsecutiveErrors = 3;
      
      const interval = setInterval(() => {
        if (consecutiveErrors >= maxConsecutiveErrors) {
          console.warn(`[Chat] Skipping polling due to ${consecutiveErrors} consecutive errors`);
          return;
        }
        
        // Check unread count first
        getUnreadCount()
          .then(unreadResponse => {
            const unreadCount = unreadResponse.count || unreadResponse.data?.count || 0;
            
            // If there are unread messages, refresh the messages
            if (unreadCount > 0) {
              console.log(`[Chat] Detected ${unreadCount} unread message(s), refreshing conversation`);
              
              // Get the latest messages
              return getMessages(friendId as string);
            }
            return null;
          })
          .then((messagesResponse) => {
            if (messagesResponse) {
              // Process new messages if any were fetched
              const hasValidData = messagesResponse?.data && Array.isArray(messagesResponse.data) && messagesResponse.data.length > 0;
              const hasValidMessages = messagesResponse?.messages && Array.isArray(messagesResponse?.messages) && messagesResponse?.messages?.length > 0;
              
              if (hasValidData || hasValidMessages) {
                const newMessages = hasValidData ? messagesResponse.data : 
                                  (hasValidMessages && messagesResponse.messages) ? messagesResponse.messages : [];
                
                // Update message list with any new messages
                setLocalMessages((prevMessages: Message[]) => {
                  // Create a map of existing message IDs for quick lookup
                  const existingIds = new Map(prevMessages.map((msg: Message) => [msg.id, true]));
                  
                  // Filter out messages we already have
                  const uniqueNewMessages = newMessages.filter((msg: any) => !existingIds.has(msg.id));
                  
                  if (uniqueNewMessages.length > 0) {
                    console.log(`[Chat] Adding ${uniqueNewMessages.length} new messages from polling`);
                    // Return new array with uniqueNewMessages appended
                    return [...prevMessages, ...uniqueNewMessages as Message[]];
                  }
                  
                  // No unique new messages
                  return prevMessages;
                });
              }
            }
            
            // Reset error counter on success
            consecutiveErrors = 0;
          })
          .catch((err) => {
            console.warn("[Chat] Error in polling for new messages:", err);
            consecutiveErrors++;
            
            // If we've hit the error threshold, notify the user but only once
            if (consecutiveErrors === maxConsecutiveErrors) {
              console.error("[Chat] Throttling message polling due to consecutive errors");
              toast.error("Having trouble refreshing messages. Will retry later.", {
                id: "message-polling-error",
                duration: 3000
              });
            }
          });
      }, 7500);  // Poll every 7.5 seconds to reduce API load

      return () => clearInterval(interval);
    }
  }, [friendId, getMessages, getMessageHistory, getFriendById, getUnreadCount]);

  // Scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [localMessages]);

  // Improved send message function with better error handling, retry logic, and optimistic UI
  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() || !friendId) return;

    const messageContent = message.trim();
    // Clear message input early for better UX
    setMessage("");

    // Create a temporary message for optimistic UI update
    const tempId = `temp-${Date.now()}`;

    // Update pending status
    setPendingMessages((prev) => ({ ...prev, [tempId]: true }));

    const tempMessage = {
      id: tempId,
      sender_id: session?.user?.id || "",
      recipient_id: friendId,
      content: messageContent,
      type: "text",
      read: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      sender: {
        id: session?.user?.id || "",
        name: session?.user?.name || "You",
        profile_picture_url: session?.user?.image,
      },
      // Visual indicators for the message state
      pending: true,
      error: false,
    };

    // Add to local messages immediately for better UX
    setLocalMessages((prevMessages: Message[]) => [...prevMessages, tempMessage]);

    // Scroll to bottom immediately after adding message
    setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, 50);

    // Define a sendWithRetry function for better error handling
    const sendWithRetry = async (retryCount = 0, maxRetries = 3): Promise<any> => {
      try {
        // Log attempt number if retrying
        if (retryCount > 0) {
          console.log(`[Chat] Retry attempt ${retryCount} for message to ${friendId}`);
          
          // Update UI to show retrying status
          setLocalMessages((prevMessages: Message[]) =>
            prevMessages.map((msg: Message) =>
              msg.id === tempId ? { ...msg, pending: true, retrying: true, error: false } : msg
            )
          );
        } else {
          console.log(`[Chat] Sending message to ${friendId}: ${messageContent.substring(0, 20)}...`);
        }

        // Clearly indicate we're using POST /messages endpoint for sending messages
        console.log(`[Chat] Using POST /messages endpoint to send message to recipient: ${friendId}`);
        
        // Send the actual message with a timeout handler
        const sendPromise = sendMessage(friendId as string, messageContent);
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error("Request timed out")), 10000);
        });

        // Race between the send operation and timeout
        const response = await Promise.race([sendPromise, timeoutPromise]);

        // Success: clear pending status and update the message
        setPendingMessages((prev) => {
          const newState = { ...prev };
          delete newState[tempId];
          return newState;
        });

        // Replace temp message with real message data
        setLocalMessages((prevMessages: Message[]) =>
          prevMessages.map((msg: Message) => {
            if (msg.id === tempId) {
              // Handle response data safely with type assertions
              const responseObj = response as any; // Use type assertion for dynamic access
              const responseData = responseObj?.data || responseObj?.message || {};
              const newMessageId = responseObj?.data?.id || responseObj?.message?.id || msg.id;
              
              return { 
                ...msg, 
                ...responseData,
                id: newMessageId,
                pending: false, 
                retrying: false,
                error: false 
              };
            }
            return msg;
          })
        );

        return response;
      } catch (error: any) {
        console.error(`[Chat] Error sending message (attempt ${retryCount + 1}):`, error);
        
        // If we haven't reached max retries, try again with exponential backoff
        if (retryCount < maxRetries) {
          const backoffTime = Math.min(1000 * Math.pow(2, retryCount), 8000); // Exponential backoff capped at 8 seconds
          
          console.log(`[Chat] Will retry in ${backoffTime}ms (attempt ${retryCount + 1}/${maxRetries})`);
          
          // Update UI to show retry pending
          setLocalMessages((prevMessages: Message[]) =>
            prevMessages.map((msg: Message) =>
              msg.id === tempId ? { 
                ...msg, 
                pending: true, 
                retrying: true,
                retryCount: retryCount + 1,
                error: false 
              } : msg
            )
          );
          
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, backoffTime));
          
          // Recursive retry with incremented count
          return sendWithRetry(retryCount + 1, maxRetries);
        }
        
        // All retries failed
        setPendingMessages((prev) => {
          const newState = { ...prev };
          delete newState[tempId];
          return newState;
        });
        
        setLocalMessages((prevMessages: Message[]) =>
          prevMessages.map((msg: Message) =>
            msg.id === tempId ? { 
              ...msg, 
              pending: false, 
              retrying: false,
              error: true,
              errorMessage: error?.message || "Failed to send message" 
            } : msg
          )
        );
        
        throw error; // Rethrow for outer catch block to handle
      }
    };

    // Execute the send with retry logic
    try {
      const response = await sendWithRetry();
      console.log(`[Chat] Message sent successfully:`, response);
    } catch (error) {
      console.error("[Chat] All send attempts failed:", error);
      toast.error("Failed to send message. Tap to retry.", {
        duration: 4000,
        icon: "⚠️",
      });
    }
  };

  // Format friend's name with preference for first_name and last_name
  const friendName = 
    recipientData?.first_name && recipientData?.last_name
      ? `${recipientData.first_name} ${recipientData.last_name}`
      : recipientData?.full_name || recipientData?.display_name || recipientData?.name || recipientName || "Chat";

  const isOnline = recipientData
    ? presence.getStatus(recipientData.id) === "online"
    : false;

  return (
    <div className="flex flex-col h-full">
      {/* Chat Header */}
      <div className="px-6 py-4 border-b flex items-center">
        <div className="relative mr-3">
          <div className="h-10 w-10 rounded-full overflow-hidden bg-gray-200 flex items-center justify-center">
            {recipientData?.avatar ? (
              <img
                src={recipientData.avatar}
                alt={friendName}
                className="h-full w-full object-cover"
              />
            ) : (
              <FaUser className="h-5 w-5 text-gray-500" />
            )}
          </div>
          {isOnline && (
            <div className="absolute bottom-0 right-0 h-3 w-3 rounded-full bg-green-500 border-2 border-white"></div>
          )}
        </div>
        <div>
          <h2 className="font-medium text-gray-900">{friendName}</h2>
          <p className="text-xs text-gray-500">
            {isOnline ? "Online" : "Offline"}
          </p>
        </div>
      </div>

      {/* Messages Area */}
      <div className="flex-1 overflow-y-auto p-6 bg-gray-50">
        {loadingMessages ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
          </div>
        ) : error ? (
          <div className="flex items-center justify-center h-full text-red-500">
            {error}
          </div>
        ) : localMessages.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full text-gray-400">
            <p>No messages yet</p>
            <p className="text-sm">Start the conversation!</p>
          </div>
        ) : (
          <div className="space-y-4">
            {localMessages.filter(msg => msg && typeof msg === 'object').map((msg) => {
              // Determine if the message is from the current user
              const isCurrentUser = msg.sender_id === session?.user?.id;

              // Handle message status indicators with null/undefined checks
              const isPending = !!msg.pending || (msg.id && !!pendingMessages[msg.id]);
              const hasError = msg.error === true;
              
              // Ensure we have a valid message ID before rendering
              if (!msg.id) {
                console.error("[ChatArea] Encountered message without ID:", msg);
                return null;
              }

              return (
                <div
                  key={msg.id}
                  className={`flex ${
                    isCurrentUser ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-xs md:max-w-md lg:max-w-lg xl:max-w-xl rounded-lg px-4 py-2 ${
                      isCurrentUser
                        ? hasError
                          ? "bg-red-100 text-red-800 rounded-br-none"
                          : "bg-blue-500 text-white rounded-br-none"
                        : "bg-white text-gray-800 border rounded-bl-none"
                    } ${isPending ? "opacity-70" : ""}`}
                  >
                    <p>{msg.content}</p>
                    <div className="flex justify-between items-center mt-1">
                      <p
                        className={`text-xs ${
                          isCurrentUser
                            ? hasError
                              ? "text-red-600"
                              : "text-blue-100"
                            : "text-gray-400"
                        }`}
                      >
                        {new Date(msg.created_at).toLocaleTimeString([], {
                          hour: "2-digit",
                          minute: "2-digit",
                          hour12: true,
                        })}
                      </p>
                      {isPending && !msg.retrying && (
                        <span className="ml-1 text-xs">Sending...</span>
                      )}
                      {isPending && msg.retrying && (
                        <span className="ml-1 text-xs flex items-center">
                          <span className="animate-pulse mr-1">⟳</span> 
                          Retrying {msg.retryCount}/{3}...
                        </span>
                      )}
                      {hasError && (
                        <span
                          className="ml-1 text-xs text-red-600 cursor-pointer hover:underline flex items-center"
                          onClick={() => {
                            // Retry sending the message
                            const retryContent = msg.content;
                            // Remove the failed message
                            setLocalMessages(
                              localMessages.filter((m: Message) => m.id !== msg.id)
                            );
                            // Clear the input field in case user typed something else
                            const prevMsg = message;
                            setMessage(retryContent);
                            // Submit the form programmatically
                            setTimeout(() => {
                              const form = document.querySelector("form");
                              form?.dispatchEvent(
                                new Event("submit", {
                                  cancelable: true,
                                  bubbles: true,
                                })
                              );
                              // If user had typed something else, restore it after small delay
                              if (prevMsg && prevMsg !== retryContent) {
                                setTimeout(() => setMessage(prevMsg), 200);
                              }
                            }, 100);
                          }}
                        >
                          <span className="mr-1">⟳</span>Tap to retry
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              );
            })}
            <div ref={messagesEndRef} />
          </div>
        )}
      </div>

      {/* Message Input */}
      <form onSubmit={handleSendMessage} className="px-6 py-4 border-t">
        <div className="flex items-center">
          <input
            type="text"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            placeholder="Type a message..."
            className="flex-1 border rounded-full py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-300"
          />
          <button
            type="submit"
            disabled={!message.trim()}
            className={`ml-2 rounded-full p-2 ${
              message.trim()
                ? "bg-blue-500 text-white hover:bg-blue-600"
                : "bg-gray-200 text-gray-400 cursor-not-allowed"
            }`}
          >
            <FaPaperPlane />
          </button>
        </div>
      </form>
    </div>
  );
}

// Also add default export for compatibility
export default ChatArea;
