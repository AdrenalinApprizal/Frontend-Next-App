"use client";

import React, {
  useState,
  useRef,
  useEffect,
  useMemo,
  useCallback,
} from "react";
import {
  FaUsers,
  FaPaperPlane,
  FaUser,
  FaEllipsisV,
  FaSearch,
  FaFile,
  FaImage,
  FaExclamationTriangle,
  FaTimes,
  FaInfoCircle,
  FaClock,
  FaCheck,
} from "react-icons/fa";
import { Paperclip, X, Edit2, Trash, Info } from "lucide-react";
import { toast } from "react-hot-toast";
import SearchFilterPopup from "./search-on-group";
import GroupProfileInfo from "./group-info-panel";
import GroupMessageItem from "./group-message-item";
import { useAuth } from "@/hooks/auth/useAuth";
import { useUserInfoContext } from "@/components/auth/user-info-provider";
import { useGroup } from "@/hooks/auth/useGroup";
import { useWebSocketContext } from "@/hooks/websocket/WebSocketProviderNew";
import type {
  GroupMessage as ApiGroupMessage,
  GroupMember as ApiGroupMember,
  GroupMessagesResponse,
  SendGroupMessageResponse,
  Pagination,
} from "@/hooks/auth/useGroup";

// Interface for WebSocket message data
interface NewMessageData {
  id: string;
  content: string;
  sender_id: string;
  created_at?: string;
  chatroom_id?: string;
  group_id?: string;
}

interface GroupDetailProps {
  groupId: string;
  isOwner?: boolean;
}

// Interface for group details in the component
interface GroupDetails {
  id: string;
  name: string;
  description: string;
  createdAt: string;
  memberCount: number;
  members: GroupMember[];
  avatar_url?: string;
}

// Interface for GroupMember in the component
interface GroupMember {
  id: string;
  name: string;
  status: "online" | "offline" | "busy" | "away";
  role: "admin" | "owner" | "member";
  avatar_url?: string;
  lastSeen?: string;
  isBlocked?: boolean;
  user_id?: string;
  user?: {
    id: string;
    name?: string;
    email?: string;
    profile_picture_url?: string;
  };
}

// Define a separate type for message sender to avoid conflicts
interface MessageSender {
  id: string;
  name: string;
  avatar_url: string | null | undefined;
}

// Enhanced interface for message with improved status tracking
interface GroupMessage {
  id: string;
  content: string;
  sender: MessageSender;
  timestamp: string;
  isCurrentUser: boolean;
  isEdited?: boolean;
  isDeleted?: boolean;
  attachment?: {
    type: "image" | "file";
    url: string;
    name: string;
    size?: string;
  };
  // Enhanced status tracking for better UX
  pending?: boolean;
  failed?: boolean;
  retrying?: boolean;
  delivered?: boolean;
  read?: boolean;
  readBy?: string[];
  editHistory?: { content: string; editedAt: string }[];
  replyTo?: string;
  reactions?: { emoji: string; users: string[] }[];
}

// Enhanced WebSocket message interface with better typing
interface WebSocketMessage {
  id: string;
  content: string;
  sender_id: string;
  created_at?: string;
  chatroom_id?: string;
  group_id?: string;
  type?: "message" | "file" | "image" | "typing" | "read_receipt";
  attachment?: {
    url: string;
    name: string;
    type: string;
    size?: number;
  };
  metadata?: {
    edited?: boolean;
    deleted?: boolean;
    reply_to?: string;
  };
}

// Session storage utility for message caching
const CACHE_KEY_PREFIX = "group_messages_";
const CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes

interface MessageCache {
  messages: GroupMessage[];
  timestamp: number;
  pagination: Pagination;
}

const saveMessagesToCache = (
  groupId: string,
  messages: GroupMessage[],
  pagination: Pagination
) => {
  try {
    const cacheData: MessageCache = {
      messages,
      timestamp: Date.now(),
      pagination,
    };
    sessionStorage.setItem(
      `${CACHE_KEY_PREFIX}${groupId}`,
      JSON.stringify(cacheData)
    );
  } catch (error) {
    console.warn("Failed to save messages to cache:", error);
  }
};

const loadMessagesFromCache = (groupId: string): MessageCache | null => {
  try {
    const cached = sessionStorage.getItem(`${CACHE_KEY_PREFIX}${groupId}`);
    if (!cached) return null;

    const cacheData: MessageCache = JSON.parse(cached);

    // Check if cache is expired
    if (Date.now() - cacheData.timestamp > CACHE_EXPIRY) {
      sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
      return null;
    }

    return cacheData;
  } catch (error) {
    console.warn("Failed to load messages from cache:", error);
    return null;
  }
};

// Main GroupDetail component with all handlers and state management
const GroupDetail: React.FC<GroupDetailProps> = ({ groupId, isOwner }) => {
  // State management for the component
  const [messages, setMessages] = useState<GroupMessage[]>([]);
  const [inputMessage, setInputMessage] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [groupDetails, setGroupDetails] = useState<GroupDetails>({
    id: groupId,
    name: "Loading...",
    description: "Loading...",
    createdAt: "",
    memberCount: 0,
    members: [],
    avatar_url: undefined,
  });
  const [pagination, setPagination] = useState({
    current_page: 1,
    total_pages: 1,
    total_items: 0,
    items_per_page: 20,
    has_more_pages: false,
  });
  const [canLoadMoreMessages, setCanLoadMoreMessages] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [dragOver, setDragOver] = useState(false);
  const [uploadProgress, setUploadProgress] = useState<{
    [key: string]: number;
  }>({});
  const [showProfile, setShowProfile] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<
    "connected" | "disconnected"
  >("disconnected");

  // Search related states
  const [showSearch, setShowSearch] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedMembers, setSelectedMembers] = useState<string[]>([]);
  const [filteredMessages, setFilteredMessages] = useState<GroupMessage[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  // Edit and delete message states
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null);

  // Refs for managing scrolling and typing timeouts
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Get user info and WebSocket context
  const { user } = useAuth();
  const { userInfo } = useUserInfoContext();
  const {
    getGroupDetails,
    getGroupMembers,
    getGroupMessages,
    sendGroupMessage,
    sendGroupMessageWithAttachment,
    editGroupMessage,
    deleteGroupMessage,
    blockedUsers,
  } = useGroup();
  const {
    messages: wsMessages,
    isConnected,
    error: wsError,
  } = useWebSocketContext();

  // Enhanced user ID detection - Use userInfo from UserInfoContext
  const currentUserId = useMemo(() => {
    // Try to get user ID from multiple sources
    const userId = userInfo?.user_id || user?.id;
    return userId;
  }, [user, userInfo]);

  // Enhanced message ownership detection function
  const isMessageFromCurrentUser = useCallback(
    (senderId: any): boolean => {
      if (!currentUserId) {
        return false;
      }

      // Handle different sender ID formats
      let actualSenderId = senderId;
      if (typeof senderId === "object" && senderId !== null) {
        actualSenderId = senderId.id || senderId.user_id || senderId.sender_id;
      }

      // Convert both to strings and trim whitespace for comparison
      const currentUserIdStr = String(currentUserId).trim();
      const senderIdStr = String(actualSenderId).trim();

      const isCurrentUser = currentUserIdStr === senderIdStr;

      return isCurrentUser;
    },
    [currentUserId, user]
  );

  // Enhanced sender name resolution function
  const resolveSenderName = useCallback(
    (
      senderId: any,
      isFromCurrentUser: boolean
    ): { name: string; avatar: string | null } => {
      // If it's the current user, return "You"
      if (isFromCurrentUser) {
        return {
          name: "You",
          avatar:
            userInfo?.profile_picture_url || user?.profile_picture_url || null,
        };
      }

      // Handle different sender ID formats
      let actualSenderId = senderId;
      if (typeof senderId === "object" && senderId !== null) {
        actualSenderId = senderId.id || senderId.user_id || senderId.sender_id;
      }

      const senderIdStr = String(actualSenderId).trim();

      // Find the member by ID - check both user_id and id fields
      const matchedMember = groupDetails.members?.find((member) => {
        const memberUserId = String(member.user_id || member.id).trim();
        const memberIdMatch = memberUserId === senderIdStr;

        // Also check if the member.user object exists and matches
        const userIdMatch =
          member.user?.id && String(member.user.id).trim() === senderIdStr;

        return memberIdMatch || userIdMatch;
      });

      if (matchedMember) {
        return {
          name:
            matchedMember.name || matchedMember.user?.name || "Unknown User",
          avatar:
            matchedMember.avatar_url ||
            matchedMember.user?.profile_picture_url ||
            null,
        };
      }

      // Fallback to a simple name
      return {
        name: `User ${senderIdStr.substring(0, 8)}`,
        avatar: null,
      };
    },
    [
      groupDetails.members,
      user?.profile_picture_url,
      userInfo?.profile_picture_url,
    ]
  );

  // Utility functions for file handling
  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  const getFileTypeFromUrl = (url: string): "image" | "file" => {
    const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp"];
    return imageExtensions.some((ext) => url.toLowerCase().includes(ext))
      ? "image"
      : "file";
  };

  const getFileNameFromUrl = (url: string): string => {
    const urlParts = url.split("/");
    return urlParts[urlParts.length - 1] || "attachment";
  };

  // Auto-scroll to bottom when new messages arrive
  const scrollToBottom = () => {
    setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, 100);
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Fetch group details when component mounts or groupId changes
  useEffect(() => {
    const fetchGroupDetails = async () => {
      try {
        setIsLoading(true);

        const groupData = await getGroupDetails(groupId);
        const membersData = await getGroupMembers(groupId);

        // Simple member processing
        const processedMembers = (membersData?.members || []).map(
          (member: ApiGroupMember) => {
            const memberName =
              member.user?.name || member.full_name || "Unknown User";

            const formattedMember: GroupMember = {
              id: member.id || member.user_id,
              name: memberName,
              status: "offline" as const,
              role: member.is_owner ? ("admin" as const) : ("member" as const),
              avatar_url: member.avatar_url || member.user?.profile_picture_url,
              lastSeen: "Not available",
              user_id: member.user_id,
            };

            return formattedMember;
          }
        );

        setGroupDetails({
          id: groupData.id,
          name: groupData.name,
          description:
            groupData.description ||
            "Group for team collaboration and discussions.",
          createdAt: new Date(groupData.created_at).toLocaleDateString(
            "en-US",
            {
              year: "numeric",
              month: "long",
              day: "numeric",
            }
          ),
          memberCount: groupData.member_count,
          members: processedMembers,
          avatar_url: groupData.avatar_url,
        });
      } catch (error: any) {
        console.error("Error fetching group details:", error);
        setError("Failed to load group details");
        toast.error("Failed to load group details");
      } finally {
        setIsLoading(false);
      }
    };

    fetchGroupDetails();
  }, [groupId]);

  // Force refresh messages from backend without cache
  const forceRefreshMessages = useCallback(
    async (page = 1, limit = 20) => {
      console.log(
        `[GroupChat] Force refreshing messages for group ${groupId} (bypassing cache)`
      );

      // Clear cache first
      if (typeof window !== "undefined") {
        sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
        console.log(`[GroupChat] Cleared cache before force refresh`);
      }

      try {
        setLoadingMessages(true);
        const messagesData = await getGroupMessages(groupId, page, limit);
        console.log(
          `[GroupChat] Force refresh got ${
            messagesData.messages?.length || 0
          } messages from backend`
        );

        const paginationData = {
          current_page: messagesData.current_page || page,
          total_pages: Math.ceil((messagesData.total || 0) / limit) || 1,
          total_items: messagesData.total || messagesData.messages?.length || 0,
          items_per_page: limit,
          has_more_pages:
            (messagesData.current_page || 1) <
            (Math.ceil((messagesData.total || 0) / limit) || 1),
        };

        setCanLoadMoreMessages(!!paginationData?.has_more_pages);

        // Simple message transformation
        const formattedMessages = messagesData.messages.map(
          (apiMsg: ApiGroupMessage) => {
            const messageId = apiMsg.id || `msg-${Date.now()}-${Math.random()}`;
            const isCurrentUser = isMessageFromCurrentUser(apiMsg.sender_id);
            const senderInfo = resolveSenderName(
              apiMsg.sender_id,
              isCurrentUser
            );

            let attachment = undefined;
            if (apiMsg.attachment_url) {
              const fileType = getFileTypeFromUrl(apiMsg.attachment_url);
              const fileName = getFileNameFromUrl(apiMsg.attachment_url);

              attachment = {
                type: fileType,
                url: apiMsg.attachment_url,
                name: fileName,
                size: "Unknown size",
              };
            }

            const message: GroupMessage = {
              id: messageId,
              content: apiMsg.content || "",
              sender: {
                id: apiMsg.sender_id,
                name: senderInfo.name,
                avatar_url: senderInfo.avatar,
              },
              timestamp:
                apiMsg.sent_at || apiMsg.created_at || new Date().toISOString(),
              isCurrentUser: isCurrentUser,
              attachment: attachment,
              pending: false,
              failed: false,
              delivered: true,
              // Preserve edit/delete state from API if available
              isEdited: Boolean(
                (apiMsg as any).isEdited || (apiMsg as any).is_edited
              ),
              isDeleted: Boolean(
                (apiMsg as any).isDeleted || (apiMsg as any).is_deleted
              ),
            };

            return message;
          }
        );

        const sortedMessages = formattedMessages.sort(
          (a: GroupMessage, b: GroupMessage) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );

        console.log(
          `[GroupChat] Force refresh setting ${sortedMessages.length} messages to state (preserving local edits)`
        );

        // Preserve locally edited/deleted messages even during force refresh
        setMessages((prevMessages) => {
          const editedOrDeletedMessages = prevMessages.filter(
            (msg) => msg.isEdited || msg.isDeleted
          );

          console.log(
            `[GroupChat] Preserving ${editedOrDeletedMessages.length} locally modified messages`
          );

          // Merge fresh data with locally modified messages
          const freshMessages = sortedMessages.filter(
            (freshMsg) =>
              !editedOrDeletedMessages.some(
                (localMsg) => localMsg.id === freshMsg.id
              )
          );

          const mergedMessages = [...freshMessages, ...editedOrDeletedMessages];
          return mergedMessages.sort(
            (a, b) =>
              new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        });

        return messagesData;
      } catch (error: any) {
        console.error("Force refresh failed:", error);
        toast.error("Failed to refresh messages");
        throw error;
      } finally {
        setLoadingMessages(false);
      }
    },
    [groupId, getGroupMessages, isMessageFromCurrentUser, resolveSenderName]
  );

  // Function to fetch group messages with pagination support
  const fetchGroupMessages = useCallback(
    async (page = 1, limit = 20) => {
      try {
        setLoadingMessages(true);
        const messagesData = await getGroupMessages(groupId, page, limit);

        const paginationData = {
          current_page: messagesData.current_page || page,
          total_pages: Math.ceil((messagesData.total || 0) / limit) || 1,
          total_items: messagesData.total || messagesData.messages?.length || 0,
          items_per_page: limit,
          has_more_pages:
            (messagesData.current_page || 1) <
            (Math.ceil((messagesData.total || 0) / limit) || 1),
        };

        setCanLoadMoreMessages(!!paginationData?.has_more_pages);

        // Simple message transformation
        const formattedMessages = messagesData.messages.map(
          (apiMsg: ApiGroupMessage) => {
            const messageId = apiMsg.id || `msg-${Date.now()}-${Math.random()}`;
            const isCurrentUser = isMessageFromCurrentUser(apiMsg.sender_id);
            const senderInfo = resolveSenderName(
              apiMsg.sender_id,
              isCurrentUser
            );

            let attachment = undefined;
            if (apiMsg.attachment_url) {
              const fileType = getFileTypeFromUrl(apiMsg.attachment_url);
              const fileName = getFileNameFromUrl(apiMsg.attachment_url);

              attachment = {
                type: fileType,
                url: apiMsg.attachment_url,
                name: fileName,
                size: "Unknown size",
              };
            }

            const message: GroupMessage = {
              id: messageId,
              content: apiMsg.content || "",
              sender: {
                id: apiMsg.sender_id,
                name: senderInfo.name,
                avatar_url: senderInfo.avatar,
              },
              timestamp:
                apiMsg.sent_at || apiMsg.created_at || new Date().toISOString(),
              isCurrentUser: isCurrentUser,
              attachment: attachment,
              pending: false,
              failed: false,
              delivered: true,
              // Preserve edit/delete state from API if available
              isEdited: Boolean(
                (apiMsg as any).isEdited || (apiMsg as any).is_edited
              ),
              isDeleted: Boolean(
                (apiMsg as any).isDeleted || (apiMsg as any).is_deleted
              ),
            };

            return message;
          }
        );

        const sortedMessages = formattedMessages.sort(
          (a: GroupMessage, b: GroupMessage) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );

        console.log(
          `[GroupChat] fetchGroupMessages loaded ${sortedMessages.length} messages from backend`
        );

        // Log first few messages for debugging
        if (sortedMessages.length > 0) {
          console.log(
            `[GroupChat] Sample messages:`,
            sortedMessages.slice(0, 3).map((msg) => ({
              id: msg.id,
              content:
                msg.content.substring(0, 50) +
                (msg.content.length > 50 ? "..." : ""),
              isEdited: msg.isEdited,
              isDeleted: msg.isDeleted,
              timestamp: msg.timestamp,
            }))
          );
        }

        if (page === 1) {
          // For fresh data load, preserve any locally edited/deleted messages
          setMessages((prevMessages) => {
            const editedOrDeletedMessages = prevMessages.filter(
              (msg) => msg.isEdited || msg.isDeleted
            );

            // Merge fresh data with locally modified messages
            const freshMessages = sortedMessages.filter(
              (freshMsg) =>
                !editedOrDeletedMessages.some(
                  (localMsg) => localMsg.id === freshMsg.id
                )
            );

            const mergedMessages = [
              ...freshMessages,
              ...editedOrDeletedMessages,
            ];
            return mergedMessages.sort(
              (a, b) =>
                new Date(a.timestamp).getTime() -
                new Date(b.timestamp).getTime()
            );
          });
        } else {
          setMessages((prevMessages) => [...sortedMessages, ...prevMessages]);
        }

        return messagesData;
      } catch (error: any) {
        console.error("Error fetching group messages:", error);
        setError("Failed to load messages");
        toast.error("Failed to load messages");
        throw error;
      } finally {
        setLoadingMessages(false);
      }
    },
    [groupId, getGroupMessages, isMessageFromCurrentUser, resolveSenderName]
  );

  // Force refresh messages from backend without cache
  const forceRefreshMessages = useCallback(
    async (page = 1, limit = 20) => {
      console.log(
        `[GroupChat] Force refreshing messages for group ${groupId} (bypassing cache)`
      );

      // Clear cache first
      if (typeof window !== "undefined") {
        sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
        console.log(`[GroupChat] Cleared cache before force refresh`);
      }

      try {
        setLoadingMessages(true);
        const messagesData = await getGroupMessages(groupId, page, limit);
        console.log(
          `[GroupChat] Force refresh got ${
            messagesData.messages?.length || 0
          } messages from backend`
        );

        const paginationData = {
          current_page: messagesData.current_page || page,
          total_pages: Math.ceil((messagesData.total || 0) / limit) || 1,
          total_items: messagesData.total || messagesData.messages?.length || 0,
          items_per_page: limit,
          has_more_pages:
            (messagesData.current_page || 1) <
            (Math.ceil((messagesData.total || 0) / limit) || 1),
        };

        setCanLoadMoreMessages(!!paginationData?.has_more_pages);

        // Simple message transformation
        const formattedMessages = messagesData.messages.map(
          (apiMsg: ApiGroupMessage) => {
            const messageId = apiMsg.id || `msg-${Date.now()}-${Math.random()}`;
            const isCurrentUser = isMessageFromCurrentUser(apiMsg.sender_id);
            const senderInfo = resolveSenderName(
              apiMsg.sender_id,
              isCurrentUser
            );

            let attachment = undefined;
            if (apiMsg.attachment_url) {
              const fileType = getFileTypeFromUrl(apiMsg.attachment_url);
              const fileName = getFileNameFromUrl(apiMsg.attachment_url);

              attachment = {
                type: fileType,
                url: apiMsg.attachment_url,
                name: fileName,
                size: "Unknown size",
              };
            }

            const message: GroupMessage = {
              id: messageId,
              content: apiMsg.content || "",
              sender: {
                id: apiMsg.sender_id,
                name: senderInfo.name,
                avatar_url: senderInfo.avatar,
              },
              timestamp:
                apiMsg.sent_at || apiMsg.created_at || new Date().toISOString(),
              isCurrentUser: isCurrentUser,
              attachment: attachment,
              pending: false,
              failed: false,
              delivered: true,
              // Preserve edit/delete state from API if available
              isEdited: Boolean(
                (apiMsg as any).isEdited || (apiMsg as any).is_edited
              ),
              isDeleted: Boolean(
                (apiMsg as any).isDeleted || (apiMsg as any).is_deleted
              ),
            };

            return message;
          }
        );

        const sortedMessages = formattedMessages.sort(
          (a: GroupMessage, b: GroupMessage) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );

        console.log(
          `[GroupChat] Force refresh setting ${sortedMessages.length} messages to state (preserving local edits)`
        );

        // Preserve locally edited/deleted messages even during force refresh
        setMessages((prevMessages) => {
          const editedOrDeletedMessages = prevMessages.filter(
            (msg) => msg.isEdited || msg.isDeleted
          );

          console.log(
            `[GroupChat] Preserving ${editedOrDeletedMessages.length} locally modified messages`
          );

          // Merge fresh data with locally modified messages
          const freshMessages = sortedMessages.filter(
            (freshMsg) =>
              !editedOrDeletedMessages.some(
                (localMsg) => localMsg.id === freshMsg.id
              )
          );

          const mergedMessages = [...freshMessages, ...editedOrDeletedMessages];
          return mergedMessages.sort(
            (a, b) =>
              new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        });

        return messagesData;
      } catch (error: any) {
        console.error("Force refresh failed:", error);
        toast.error("Failed to refresh messages");
        throw error;
      } finally {
        setLoadingMessages(false);
      }
    },
    [groupId, getGroupMessages, isMessageFromCurrentUser, resolveSenderName]
  );

  // Auto-refresh messages periodically to catch any updates from other clients
  useEffect(() => {
    if (!groupId) return;
    
    const intervalId = setInterval(() => {
      console.log('[GroupChat] Auto-refresh: checking for new messages');
      forceRefreshMessages(1, 20);
    }, 30000); // Refresh every 30 seconds
    
    return () => {
      clearInterval(intervalId);
    };
  }, [groupId, forceRefreshMessages]);

  // Fetch messages when group ID changes or initially
  useEffect(() => {
    // Clear any existing cache for this group when loading fresh data
    if (typeof window !== "undefined") {
      sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
      console.log(
        `[GroupChat] Cleared cache for group ${groupId} on component mount`
      );
    }
    fetchGroupMessages(1, 20);
  }, [groupId, fetchGroupMessages]);

  // Enhanced message sending with optimistic update and forced refresh
      if (typeof window !== "undefined") {
        sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
        console.log(`[GroupChat] Cleared cache before force refresh`);
      }

      try {
        setLoadingMessages(true);
        const messagesData = await getGroupMessages(groupId, page, limit);
        console.log(
          `[GroupChat] Force refresh got ${
            messagesData.messages?.length || 0
          } messages from backend`
        );

        const paginationData = {
          current_page: messagesData.current_page || page,
          total_pages: Math.ceil((messagesData.total || 0) / limit) || 1,
          total_items: messagesData.total || messagesData.messages?.length || 0,
          items_per_page: limit,
          has_more_pages:
            (messagesData.current_page || 1) <
            (Math.ceil((messagesData.total || 0) / limit) || 1),
        };

        setCanLoadMoreMessages(!!paginationData?.has_more_pages);

        // Simple message transformation
        const formattedMessages = messagesData.messages.map(
          (apiMsg: ApiGroupMessage) => {
            const messageId = apiMsg.id || `msg-${Date.now()}-${Math.random()}`;
            const isCurrentUser = isMessageFromCurrentUser(apiMsg.sender_id);
            const senderInfo = resolveSenderName(
              apiMsg.sender_id,
              isCurrentUser
            );

            let attachment = undefined;
            if (apiMsg.attachment_url) {
              const fileType = getFileTypeFromUrl(apiMsg.attachment_url);
              const fileName = getFileNameFromUrl(apiMsg.attachment_url);

              attachment = {
                type: fileType,
                url: apiMsg.attachment_url,
                name: fileName,
                size: "Unknown size",
              };
            }

            const message: GroupMessage = {
              id: messageId,
              content: apiMsg.content || "",
              sender: {
                id: apiMsg.sender_id,
                name: senderInfo.name,
                avatar_url: senderInfo.avatar,
              },
              timestamp:
                apiMsg.sent_at || apiMsg.created_at || new Date().toISOString(),
              isCurrentUser: isCurrentUser,
              attachment: attachment,
              pending: false,
              failed: false,
              delivered: true,
              // Preserve edit/delete state from API if available
              isEdited: Boolean(
                (apiMsg as any).isEdited || (apiMsg as any).is_edited
              ),
              isDeleted: Boolean(
                (apiMsg as any).isDeleted || (apiMsg as any).is_deleted
              ),
            };

            return message;
          }
        );

        const sortedMessages = formattedMessages.sort(
          (a: GroupMessage, b: GroupMessage) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );

        console.log(
          `[GroupChat] Force refresh setting ${sortedMessages.length} messages to state (preserving local edits)`
        );

        // Preserve locally edited/deleted messages even during force refresh
        setMessages((prevMessages) => {
          const editedOrDeletedMessages = prevMessages.filter(
            (msg) => msg.isEdited || msg.isDeleted
          );

          console.log(
            `[GroupChat] Preserving ${editedOrDeletedMessages.length} locally modified messages`
          );

          // Merge fresh data with locally modified messages
          const freshMessages = sortedMessages.filter(
            (freshMsg) =>
              !editedOrDeletedMessages.some(
                (localMsg) => localMsg.id === freshMsg.id
              )
          );

          const mergedMessages = [...freshMessages, ...editedOrDeletedMessages];
          return mergedMessages.sort(
            (a, b) =>
              new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        });

        return messagesData;
      } catch (error: any) {
        console.error("Force refresh failed:", error);
        toast.error("Failed to refresh messages");
        throw error;
      } finally {
        setLoadingMessages(false);
      }
    },
    [groupId, getGroupMessages, isMessageFromCurrentUser, resolveSenderName]
  );

  // Enhanced message sending with optimistic update and forced refresh
  const handleSendMessage = useCallback(async () => {
    if (!inputMessage.trim() || isSending) return;

    const messageContent = inputMessage.trim();
    const tempId = `temp-${Date.now()}-${Math.random()}`;

    try {
      setIsSending(true);
      setInputMessage("");

      // Optimistic update - add message immediately
      const optimisticMessage: GroupMessage = {
        id: tempId,
        content: messageContent,
        sender: {
          id: String(currentUserId),
          name: "You",
          avatar_url:
            userInfo?.profile_picture_url || user?.profile_picture_url || null,
        },
        timestamp: new Date().toISOString(),
        isCurrentUser: true,
        pending: true,
        failed: false,
        delivered: false,
      };

      setMessages((prevMessages) => [...prevMessages, optimisticMessage]);

      // Send message via API
      const response = await sendGroupMessage(groupId, messageContent);
      console.log("[GroupChat] Message sent response:", response);

      // Update the optimistic message to show as sent
      setMessages((prevMessages) =>
        prevMessages.map((msg) =>
          msg.id === tempId ? { ...msg, pending: false, delivered: true } : msg
        )
      );
      
      // Force refresh messages to ensure server state is synchronized
      setTimeout(() => {
        forceRefreshMessages(1, 20);
        console.log("[GroupChat] Forcing message refresh after sending");
      }, 500);
    } catch (error) {
      console.error("Failed to send message:", error);
      toast.error("Failed to send message");

      // Mark the optimistic message as failed
      setMessages((prevMessages) =>
        prevMessages.map((msg) =>
          msg.id === tempId ? { ...msg, pending: false, failed: true } : msg
        )
      );

      // Restore input on error
      setInputMessage(messageContent);
    } finally {
      setIsSending(false);
    }
  }, [
    inputMessage,
    isSending,
    groupId,
    sendGroupMessage,
    currentUserId,
    userInfo,
    user,
    forceRefreshMessages,
  ]);

  // Enhanced edit message functionality (like chat-area)
  const handleEditMessage = useCallback(
    (messageId: string) => {
      const message = messages.find((msg) => msg.id === messageId);
      if (message && !message.isDeleted && !message.pending) {
        setEditingMessageId(messageId);
        setInputMessage(message.content);
        console.log(`[GroupChat] Editing message: ${messageId}`);
      }
    },
    [messages]
  );

  // Handle cancel edit with cleanup (like chat-area)
  const handleCancelEdit = useCallback(() => {
    setEditingMessageId(null);
    setInputMessage("");
    console.log("[GroupChat] Edit cancelled");
  }, []);

  // Handle submit edit (like chat-area)
  const handleSubmitEdit = useCallback(async () => {
    if (!editingMessageId || !inputMessage.trim()) return;

    const messageContent = inputMessage.trim();
    const originalMessage = messages.find((msg) => msg.id === editingMessageId);

    if (!originalMessage) return;

    setIsSending(true);

    try {
      console.log(
        "ðŸ”§ EDIT: Starting edit for message:",
        editingMessageId,
        "New content:",
        messageContent
      );

      // Update message optimistically
      setMessages((prevMessages) =>
        prevMessages.map((msg) =>
          msg.id === editingMessageId
            ? {
                ...msg,
                content: messageContent,
                isEdited: true,
                pending: true,
              }
            : msg
        )
      );

      // Call API to edit message
      console.log("ðŸ”§ EDIT: Calling editGroupMessage API...");
      const response = await editGroupMessage(
        groupId,
        editingMessageId,
        messageContent
      );
      console.log("ðŸ”§ EDIT: API response:", response);

      // Update with successful edit
      setMessages((prevMessages) => {
        const updatedMessages = prevMessages.map((msg) =>
          msg.id === editingMessageId
            ? {
                ...msg,
                content: messageContent,
                isEdited: true,
                pending: false,
              }
            : msg
        );
        return updatedMessages;
      });
      
      // Force refresh messages to ensure server state is synchronized
      setTimeout(() => {
        forceRefreshMessages(1, 20);
        console.log("[GroupChat] Forcing message refresh after edit");
      }, 500);

      // Clear edit state
      setEditingMessageId(null);
      setInputMessage("");

      // Invalidate cache to ensure fresh data on next load
      if (typeof window !== "undefined") {
        sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
        console.log(
          `[GroupChat] Cleared cache after edit for group ${groupId}`
        );
      }

      toast.success("Message updated successfully");
      console.log(
        `[GroupChat] Message edited successfully: ${editingMessageId}`
      );
    } catch (error: any) {
      console.error("ðŸ”§ EDIT ERROR: Failed to edit message:", error);

      // Show more specific error message
      const errorMessage =
        error?.message || error?.error || "Failed to edit message";
      const statusCode = error?.status || error?.statusCode;

      if (statusCode === 404) {
        toast.error("Edit failed: Message not found or endpoint not available");
      } else if (statusCode === 500) {
        toast.error("Edit failed: Server error - please try again later");
      } else if (statusCode === 403) {
        toast.error(
          "Edit failed: You don't have permission to edit this message"
        );
      } else {
        toast.error(`Edit failed: ${errorMessage}`);
      }

      // Revert optimistic update on error
      setMessages((prevMessages) =>
        prevMessages.map((msg) =>
          msg.id === editingMessageId
            ? { ...originalMessage, pending: false }
            : msg
        )
      );
    } finally {
      setIsSending(false);
    }
  }, [editingMessageId, inputMessage, messages, editGroupMessage, groupId, forceRefreshMessages]);

  // Enhanced form submission handler for both new messages and edits (like chat-area)
  const handleFormSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();

      // Handle edit submission
      if (editingMessageId) {
        await handleSubmitEdit();
        return;
      }

      // Handle new message submission
      await handleSendMessage();
    },
    [editingMessageId, handleSubmitEdit, handleSendMessage]
  );

  // Handle Enter key for sending messages or submitting edits
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if (editingMessageId) {
        handleSubmitEdit();
      } else {
        handleSendMessage();
      }
    }
  };

  // Enhanced delete message handler with confirmation (like chat-area)
  const handleDeleteMessage = useCallback(
    async (messageId: string) => {
      const message = messages.find((msg) => msg.id === messageId);
      if (!message) return;

      // Show confirmation using react-hot-toast instead of window.confirm
      const shouldDelete = await new Promise<boolean>((resolve) => {
        toast(
          (t) => (
            <div className="flex flex-col">
              <p className="font-medium">Delete Message</p>
              <p className="text-sm text-gray-600 mb-3">
                Are you sure you want to delete this message? This action cannot
                be undone.
              </p>
              <div className="flex gap-2">
                <button
                  onClick={() => {
                    toast.dismiss(t.id);
                    resolve(true);
                  }}
                  className="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm"
                >
                  Delete
                </button>
                <button
                  onClick={() => {
                    toast.dismiss(t.id);
                    resolve(false);
                  }}
                  className="bg-gray-300 hover:bg-gray-400 text-gray-700 px-3 py-1 rounded text-sm"
                >
                  Cancel
                </button>
              </div>
            </div>
          ),
          {
            duration: Infinity,
            style: { minWidth: "300px" },
          }
        );
      });

      if (!shouldDelete) return;

      console.log("ðŸ—‘ï¸ DELETE: Starting delete for message:", messageId);
      console.log("ðŸ—‘ï¸ DELETE: Group ID:", groupId);

      try {
        // Optimistically mark message as deleted
        setMessages((prevMessages) =>
          prevMessages.map((msg) =>
            msg.id === messageId
              ? {
                  ...msg,
                  content: "This message was deleted",
                  isDeleted: true,
                  pending: true,
                }
              : msg
          )
        );

        // Call API to delete message
        console.log("ðŸ—‘ï¸ DELETE: Calling deleteGroupMessage API...");
        const response = await deleteGroupMessage(groupId, messageId);
        console.log("ðŸ—‘ï¸ DELETE: API response:", response);

        // Confirm deletion
        setMessages((prevMessages) => {
          const updatedMessages = prevMessages.map((msg) =>
            msg.id === messageId ? { ...msg, pending: false } : msg
          );
          return updatedMessages;
        });
        
        // Force refresh messages to ensure server state is synchronized
        setTimeout(() => {
          forceRefreshMessages(1, 20);
          console.log("[GroupChat] Forcing message refresh after deletion");
        }, 500);

        // Invalidate cache to ensure fresh data on next load
        if (typeof window !== "undefined") {
          sessionStorage.removeItem(`${CACHE_KEY_PREFIX}${groupId}`);
          console.log(
            `[GroupChat] Cleared cache after delete for group ${groupId}`
          );
        }

        toast.success("Message deleted successfully");
        console.log(`[GroupChat] Message deleted: ${messageId}`);
      } catch (error: any) {
        console.error("ðŸ—‘ï¸ DELETE ERROR: Failed to delete message:", error);

        // Show more specific error message
        const errorMessage =
          error?.message || error?.error || "Failed to delete message";
        const statusCode = error?.status || error?.statusCode;

        if (statusCode === 404) {
          toast.error(
            "Delete failed: Message not found or endpoint not available"
          );
        } else if (statusCode === 500) {
          toast.error("Delete failed: Server error - please try again later");
        } else if (statusCode === 403) {
          toast.error(
            "Delete failed: You don't have permission to delete this message"
          );
        } else {
          toast.error(`Delete failed: ${errorMessage}`);
        }

        // Revert optimistic update on error
        setMessages((prevMessages) =>
          prevMessages.map((msg) =>
            msg.id === messageId
              ? { ...message, pending: false, isDeleted: false }
              : msg
          )
        );
      }
    },
    [messages, deleteGroupMessage, groupId, forceRefreshMessages]
  );

  // Retry failed message handler
  const handleRetryMessage = useCallback(
    async (messageId: string) => {
      const message = messages.find((msg) => msg.id === messageId);
      if (!message) return;

      try {
        // Mark message as retrying
        setMessages((prevMessages) =>
          prevMessages.map((msg) =>
            msg.id === messageId
              ? { ...msg, retrying: true, failed: false }
              : msg
          )
        );

        // Retry sending the message
        await sendGroupMessage(groupId, message.content);

        // Update message as sent
        setMessages((prevMessages) =>
          prevMessages.map((msg) =>
            msg.id === messageId
              ? { ...msg, retrying: false, delivered: true }
              : msg
          )
        );
        
        // Force refresh messages to ensure server state is synchronized
        setTimeout(() => {
          forceRefreshMessages(1, 20);
          console.log("[GroupChat] Forcing message refresh after retry");
        }, 500);

        toast.success("Message sent successfully");
      } catch (error) {
        console.error("Failed to retry message:", error);
        toast.error("Failed to send message");

        // Mark as failed again
        setMessages((prevMessages) =>
          prevMessages.map((msg) =>
            msg.id === messageId
              ? { ...msg, retrying: false, failed: true }
              : msg
          )
        );
      }
    },
    [messages, sendGroupMessage, groupId, forceRefreshMessages]
  );

  // Enhanced WebSocket message handling with edit/delete state preservation
  useEffect(() => {
    if (!wsMessages || wsMessages.length === 0 || !groupId) return;
    
    console.log(`[GroupChat] Received WebSocket messages:`, wsMessages);
    
    const newGroupMessages = wsMessages.filter(
      (msg: NewMessageData) => msg.group_id === groupId
    );

    console.log(`[GroupChat] Filtered messages for group ${groupId}:`, newGroupMessages.length);
    
    if (newGroupMessages.length === 0) return;

    const processedMessages = newGroupMessages.map((msg: NewMessageData) => {
      // Check if message is from current user
      const isFromCurrentUser = isMessageFromCurrentUser(msg.sender_id);

      // Use sender name resolution function
      const senderInfo = resolveSenderName(msg.sender_id, isFromCurrentUser);

      // Create message with proper typing
      const processedMessage: GroupMessage = {
        id: msg.id || `ws-${Date.now()}-${Math.random()}`,
        content: msg.content,
        sender: {
          id: String(msg.sender_id),
          name: senderInfo.name,
          avatar_url: senderInfo.avatar,
        },
        timestamp: msg.created_at || new Date().toISOString(),
        isCurrentUser: isFromCurrentUser,
        pending: false,
        failed: false,
        delivered: true,
      };

      return processedMessage;
    });

    // Enhanced message deduplication and handling with edit/delete preservation
    setMessages((prevMessages) => {
      const existingIds = new Set(prevMessages.map((m) => m.id));
      const uniqueNewMessages = processedMessages.filter(
        (m) => !existingIds.has(m.id)
      );

      if (uniqueNewMessages.length === 0) return prevMessages;

      // Remove any temporary/optimistic messages that match the new real messages
      const messagesWithoutOptimistic = prevMessages.filter((msg) => {
        // IMPORTANT: Always keep messages that have been edited or deleted locally
        if (msg.isEdited || msg.isDeleted) {
          console.log(
            `[GroupChat] Preserving edited/deleted message: ${msg.id}`
          );
          return true;
        }

        // Keep the message if it's not optimistic/pending OR if there's no matching real message
        if (!msg.pending && !msg.id.startsWith("temp-")) return true;

        // Check if there's a real message with similar content and timestamp
        const hasMatchingRealMessage = uniqueNewMessages.some((newMsg) => {
          const contentMatch = newMsg.content === msg.content;
          const userMatch = newMsg.isCurrentUser === msg.isCurrentUser;
          const timeDiff = Math.abs(
            new Date(newMsg.timestamp).getTime() -
              new Date(msg.timestamp).getTime()
          );
          return contentMatch && userMatch && timeDiff < 10000; // 10 second window
        });

        return !hasMatchingRealMessage;
      });

      // Filter out new WebSocket messages that would overwrite existing edited/deleted messages
      const safeNewMessages = uniqueNewMessages.filter((newMsg) => {
        const existingMessage = prevMessages.find(
          (existing) => existing.id === newMsg.id
        );
        if (
          existingMessage &&
          (existingMessage.isEdited || existingMessage.isDeleted)
        ) {
          console.log(
            `[GroupChat] Skipping WebSocket update for edited/deleted message: ${newMsg.id}`
          );
          return false; // Don't add this WebSocket message as it would overwrite local changes
        }
        return true;
      });

      const allMessages = [...messagesWithoutOptimistic, ...safeNewMessages];
      const sortedMessages = allMessages.sort(
        (a, b) =>
          new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
      );
      
      console.log(`[GroupChat] Updated messages list after WebSocket update:`, 
        sortedMessages.length, 
        `(Added ${safeNewMessages.length} new messages)`
      );
      
      // Force refresh messages if we receive a lot of new messages
      // This ensures we're fully in sync with the server
      if (safeNewMessages.length >= 5) {
        console.log('[GroupChat] Received many new messages, scheduling refresh');
        setTimeout(() => {
          forceRefreshMessages(1, 20);
        }, 500);
      }
      
      return sortedMessages;
    });
  }, [
    wsMessages,
    groupId,
    isMessageFromCurrentUser,
    resolveSenderName,
    currentUserId,
    forceRefreshMessages,
  ]);

  // Handle search functionality
  const handleSearch = (query: string, members: string[]) => {
    setSearchQuery(query);
    setSelectedMembers(members);
    setIsSearching(true);

    // First filter out blocked users' messages, then apply search filters
    const blockedFiltered = filterBlockedMessages(messages);

    // Filter messages by content and/or sender
    const filtered = blockedFiltered.filter((message) => {
      const contentMatch =
        !query.trim() ||
        message.content.toLowerCase().includes(query.toLowerCase());

      const memberMatch =
        members.length === 0 || members.includes(message.sender.id);

      return contentMatch && memberMatch;
    });

    setFilteredMessages(filtered);
  };

  // Clear search
  const clearSearch = () => {
    setSearchQuery("");
    setIsSearching(false);
    setFilteredMessages([]);
    setSelectedMembers([]);
  };

  // Filter out messages from blocked users
  const filterBlockedMessages = useCallback(
    (messagesToFilter: GroupMessage[]): GroupMessage[] => {
      if (!blockedUsers || blockedUsers.length === 0) {
        return messagesToFilter;
      }

      const filtered = messagesToFilter.filter((message) => {
        // Always show current user's messages
        if (message.isCurrentUser) {
          return true;
        }

        // Check if sender is in blocked users list - check multiple possible ID fields
        const senderId = message.sender.id;
        const isBlocked = blockedUsers.some((blockedUser) => {
          // Check both user_id and id fields as they might be stored differently
          const blockedUserId = blockedUser.user_id || blockedUser.id;
          const match = blockedUserId === senderId;

          if (match) {
            console.log(
              `Found blocked user match: sender=${senderId}, blocked=${blockedUserId}`
            );
          }

          return match;
        });

        if (isBlocked) {
          console.log(
            `Filtering out message from blocked user: ${message.sender.name} (ID: ${senderId})`
          );
          return false;
        }

        return true;
      });

      if (filtered.length !== messagesToFilter.length) {
        console.log(
          `Filtered ${
            messagesToFilter.length - filtered.length
          } messages from blocked users in group ${groupId}`
        );
        console.log(
          `Blocked users list:`,
          blockedUsers.map((u) => ({
            id: u.id,
            user_id: u.user_id,
            name: u.name,
          }))
        );
      }

      return filtered;
    },
    [blockedUsers, groupId]
  );

  // Get visible messages (filtered for blocked users, then search if applicable)
  const visibleMessages = useMemo(() => {
    // First filter out blocked users' messages
    const filteredForBlocked = filterBlockedMessages(messages);

    // Then apply search filter if searching
    return isSearching ? filteredMessages : filteredForBlocked;
  }, [messages, filteredMessages, isSearching, filterBlockedMessages]);

  // Connection status monitoring
  useEffect(() => {
    setConnectionStatus(isConnected ? "connected" : "disconnected");
  }, [isConnected]);

  // Show WebSocket errors
  useEffect(() => {
    if (wsError) {
      toast.error(`Connection error: ${wsError}`);
    }
  }, [wsError]);

  // Refresh messages when user returns to the tab from background
  useEffect(() => {
    if (!groupId || typeof document === 'undefined') return;
    
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        console.log('[GroupChat] User returned to tab, refreshing messages');
        forceRefreshMessages(1, 20);
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [groupId, forceRefreshMessages]);

  // Loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div>
          <p className="mt-2 text-gray-600">Loading group...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center text-red-600">
          <FaExclamationTriangle className="mx-auto h-8 w-8 mb-2" />
          <p>{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-full bg-white">
      {/* Main chat area */}
      <div className="flex flex-col flex-1 min-w-0">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200 bg-white">
          <div className="flex items-center space-x-3">
            <div className="relative">
              {groupDetails.avatar_url ? (
                <img
                  src={groupDetails.avatar_url}
                  alt={groupDetails.name}
                  className="w-10 h-10 rounded-full object-cover"
                />
              ) : (
                <div className="w-10 h-10 rounded-full bg-blue-500 flex items-center justify-center">
                  <FaUsers className="text-white text-lg" />
                </div>
              )}
              <div
                className={`absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-white ${
                  connectionStatus === "connected"
                    ? "bg-green-500"
                    : "bg-red-500"
                }`}
              />
            </div>
            <div>
              <h2 className="font-semibold text-gray-900">
                {groupDetails.name}
              </h2>
              <p className="text-sm text-gray-500">
                {groupDetails.memberCount} members
              </p>
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <button
              onClick={() => setShowSearch(true)}
              className="p-2 hover:bg-gray-100 rounded-full"
              title="Search in conversation"
            >
              <FaSearch className="h-5 w-5 text-gray-600" />
            </button>
            <button
              onClick={() => forceRefreshMessages(1, 20)}
              className="p-2 hover:bg-gray-100 rounded-full"
              title="Refresh messages"
              disabled={loadingMessages}
            >
              {loadingMessages ? (
                <div className="animate-spin h-5 w-5 border-2 border-gray-600 border-t-transparent rounded-full"></div>
              ) : (
                <svg
                  className="h-5 w-5 text-gray-600"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                  />
                </svg>
              )}
            </button>
            <button
              onClick={() => setShowProfile(!showProfile)}
              className="p-2 hover:bg-gray-100 rounded-full"
            >
              <Info className="h-5 w-5 text-gray-600" />
            </button>
          </div>
        </div>

        {/* Messages Area */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {loadingMessages && messages.length === 0 && (
            <div className="flex justify-center">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
            </div>
          )}

          {/* No messages placeholder when searching */}
          {isSearching && visibleMessages.length === 0 && (
            <div className="flex items-center justify-center h-full">
              <div className="text-center text-gray-500">
                <p className="mb-1">No matching messages found</p>
                <button
                  onClick={clearSearch}
                  className="text-blue-500 hover:underline"
                >
                  Clear search
                </button>
              </div>
            </div>
          )}

          {visibleMessages.map((message) => (
            <GroupMessageItem
              key={message.id}
              message={message}
              onRetryClick={handleRetryMessage}
              onEditClick={handleEditMessage}
              onDeleteClick={handleDeleteMessage}
            />
          ))}
          <div ref={messagesEndRef} />
        </div>

        {/* Message Input */}
        <div className="border-t border-gray-200 p-4">
          {/* Edit mode indicator */}
          {editingMessageId && (
            <div className="flex items-center mb-2 bg-blue-50 p-2 rounded">
              <span className="text-sm text-blue-700 flex-1">
                Editing message
              </span>
              <button
                onClick={handleCancelEdit}
                className="text-gray-600 hover:text-gray-800"
              >
                <FaTimes className="h-4 w-4" />
              </button>
            </div>
          )}

          <form onSubmit={handleFormSubmit} className="flex flex-col">
            <div className="flex items-center space-x-2">
              <button className="p-2 text-gray-400 hover:text-gray-600">
                <Paperclip className="h-5 w-5" />
              </button>

              <div className="flex-1">
                <input
                  type="text"
                  value={inputMessage}
                  onChange={(e) => setInputMessage(e.target.value)}
                  onKeyPress={handleKeyPress}
                  placeholder={
                    editingMessageId
                      ? "Edit your message..."
                      : "Type a message..."
                  }
                  className="w-full px-4 py-2 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  disabled={isSending}
                />
              </div>

              <button
                type="submit"
                disabled={!inputMessage.trim() || isSending}
                className="p-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isSending ? (
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                ) : (
                  <FaPaperPlane className="h-5 w-5" />
                )}
              </button>
            </div>
          </form>
        </div>
      </div>

      {/* Search UI Popup */}
      {showSearch && (
        <SearchFilterPopup
          groupMembers={groupDetails.members.map((member) => ({
            id: member.id,
            name: member.name,
            status: member.status === "online" ? "online" : "offline",
            role: member.role,
            avatar_url: member.avatar_url,
          }))}
          isOpen={showSearch}
          onClose={() => {
            setShowSearch(false);
            if (!searchQuery && selectedMembers.length === 0) {
              setIsSearching(false);
            }
          }}
          onSearch={handleSearch}
        />
      )}

      {/* Group Profile Sidebar */}
      {showProfile && (
        <GroupProfileInfo
          groupName={groupDetails.name}
          onClose={() => setShowProfile(false)}
          groupDetails={groupDetails}
        />
      )}
    </div>
  );
};

export default GroupDetail;
export { GroupDetail };
